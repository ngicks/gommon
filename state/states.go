// Code generated by github.com/ngicks/gommon/cmd/generate_state_impl/generate_state_impl.go. DO NOT EDIT.
package state

import "sync/atomic"


func NewWorkingState() (embedder *WorkingStateEmbedder, setter *WorkingStateSetter) {
	embedder = &WorkingStateEmbedder{}
	setter = &WorkingStateSetter{embedder}
	return
}

type WorkingStateEmbedder struct {
	s uint32
}

func (s *WorkingStateEmbedder) IsWorking() bool {
	return atomic.LoadUint32(&s.s) == 1
}

type WorkingStateSetter struct {
	inner *WorkingStateEmbedder
}

func (s *WorkingStateSetter) SetWorking(to ...bool) (swapped bool) {
	setTo := true
	for _, setState := range to {
		if !setState {
			setTo = false
		}
	}
	if setTo {
		return atomic.CompareAndSwapUint32(&s.inner.s, 0, 1)
	} else {
		return atomic.CompareAndSwapUint32(&s.inner.s, 1, 0)
	}
}

func NewEndedState() (embedder *EndedStateEmbedder, setter *EndedStateSetter) {
	embedder = &EndedStateEmbedder{}
	setter = &EndedStateSetter{embedder}
	return
}

type EndedStateEmbedder struct {
	s uint32
}

func (s *EndedStateEmbedder) IsEnded() bool {
	return atomic.LoadUint32(&s.s) == 1
}

type EndedStateSetter struct {
	inner *EndedStateEmbedder
}

func (s *EndedStateSetter) SetEnded(to ...bool) (swapped bool) {
	setTo := true
	for _, setState := range to {
		if !setState {
			setTo = false
		}
	}
	if setTo {
		return atomic.CompareAndSwapUint32(&s.inner.s, 0, 1)
	} else {
		return atomic.CompareAndSwapUint32(&s.inner.s, 1, 0)
	}
}
